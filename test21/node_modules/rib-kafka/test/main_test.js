const {expect} = require("chai");
const {Consumer, Producer} = require("../index");
const {take, filter, map, scan, tap} = require("rxjs/operators");
const _ = require("lodash");

let consumer_main_config = {
    "group.id": "kafka-test-rib",
    "client.id": "test-client-1-with-uuid",
	"metadata.broker.list": "192.168.43.204:29092, 192.168.43.204:29093, 192.168.43.204:29094",
	"enable.auto.commit": false,
    "rebalance_cb": true,
    "statistics.interval.ms": 1000,
    "topic.metadata.refresh.interval.ms": 10000,
    "metadata.max.age.ms": 30000,
    "event_cb": true
};

let consumer_topic_config = {
    "auto.offset.reset": "earliest"
};

let producer_main_config = {
    "metadata.broker.list": "192.168.43.204:29092, 192.168.43.204:29093, 192.168.43.204:29094",
	'dr_msg_cb': true,
    "topic.metadata.refresh.interval.ms": 10000,
    "metadata.max.age.ms": 30000
};

describe("Тестирование функционала", function () {
    this.timeout(300000);
    it("Тестирование отправки и получения сообщений", async function () {
        let producer = new Producer({config: producer_main_config});
        try {
            await producer.connect();
        } catch (err) {
            console.log("producer connection error ", err);
        }
        //await producer.connect();
    
        let consumer = new Consumer({config: consumer_main_config, topic_config: consumer_topic_config, topics: ["test-topic-delete"]});
        try {
            await consumer.connect();
        } catch (err) {
            console.log("connection error of consumer ", err);
        }
        //await consumer.connect();
        let consumer_obs = consumer.getObservable();
    
        let num = Math.floor(Math.random() * 10000000);
    
        let msg1 = await producer.produce("test-topic-delete", null, new Buffer("test1"), new Buffer(`${num}-key1`));
        let msg2 = await producer.produce("test-topic-delete", null, new Buffer("test2"), new Buffer(`${num}-key2`));
        let msg3 = await producer.produce("test-topic-delete", 2, new Buffer("test3"), new Buffer(`${num}-key3`));
    
        let found_messages = [];
    
        let msgs = await consumer_obs.pipe(
            map(({action_data}) => action_data),
            filter(msg => {
                if ([`${num}-key1`, `${num}-key2`, `${num}-key3`].includes(String(msg.key))) {
                    return true;
                } else {
                    return false;
                }
            }),
            scan((acc, msg) => { acc.push(msg); return acc; }, []),
            take(3)
        ).toPromise();

        /*let msgs = await (new Promise((resolve, reject) => {
            let msgs = [];
            let count = 0;
            consumer.consume((message, next) => {
                if ([`${num}-key1`, `${num}-key2`, `${num}-key3`].includes(String(message.key)) {
                    msgs.push(message);
                    count += 1;
                    if (count === 3) {
                        resolve(msgs);
                    }
                }
            });
        }));*/

        let recv_msg_1 = _.pick(msgs.find(msg => String(msg.key) === `${num}-key1`), "topic", "partition", "offset", "key");
        let recv_msg_2 = _.pick(msgs.find(msg => String(msg.key) === `${num}-key2`), "topic", "partition", "offset", "key");
        let recv_msg_3 = _.pick(msgs.find(msg => String(msg.key) === `${num}-key3`), "topic", "partition", "offset", "key");
    
        expect(recv_msg_1).to.eql(_.pick(msg1, "topic", "partition", "offset", "key"));
        expect(recv_msg_2).to.eql(_.pick(msg2, "topic", "partition", "offset", "key"));
        expect(recv_msg_3).to.eql(_.pick(msg3, "topic", "partition", "offset", "key"));

        consumer.commitMessageSync(recv_msg_1);
        consumer.commitMessageSync(recv_msg_2);
        consumer.commitMessageSync(recv_msg_3);

        consumer.disconnect();
        producer.disconnect();
    });
});
