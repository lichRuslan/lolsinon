const {expect} = require("chai");
const rewire = require("rewire");
const Rx = require("rxjs");
const {take, filter, map, scan, tap} = require("rxjs/operators");
const _ = require("lodash");
const node_rdkafka = require("node-rdkafka");
const EventEmitter = require("events");
const rib_kafka = rewire("../index");

let TEST_PRODUCER_DISCONNECTED = false;
let TEST_SENT_MESSAGES = [];
let TEST_WRITTEN_OFFSET = null;
let TEST_EVENT_BUS;

function restoreTestData () {
    TEST_PRODUCER_DISCONNECTED = false;
	TEST_SENT_MESSAGES = [];
    TEST_WRITTEN_OFFSET = null;
    TEST_EVENT_BUS = new Rx.Subject();
}

class TestKafkaProducer extends EventEmitter {
	connect (options, cb) {
        let self = this;
        TEST_EVENT_BUS.subscribe(({event, data}) => {
            self.emit(event, data);
        })
		cb(null);
    }
    
    disconnect () {
        TEST_PRODUCER_DISCONNECTED = true;
    }

	produce (topic, partition, value, key, timestamp, opaque) {
        TEST_SENT_MESSAGES.push({topic, partition, key, value, timestamp});
        if (topic === "error-topic") {
            this.emit("delivery-report", new Error("Could not produce"), {topic, partition, key, value, timestamp, opaque});
        } else {
            this.emit("delivery-report", null, {topic, partition, offset: TEST_WRITTEN_OFFSET++, key, value, timestamp, opaque});
        }
	}
	
	setPollInterval () {}
}

rib_kafka.__set__("Kafka", {
	"Producer": TestKafkaProducer
});

const Producer = rib_kafka.getProducerClass();

describe("Тестирование Producer", function () {
	it("Отправка сообщения", async function () {
        restoreTestData();
        let producer = new Producer({config: {}});
        await producer.connect();
        let sent_msg = await producer.produce("test_topic", 3, new Buffer("test"));
        expect(sent_msg.offset).to.equal(0);
    });
    
    it("Событие event", async function () {
        restoreTestData();
        let producer = new Producer({config: {}});
        await producer.connect();
        let events = [];
        producer.on("event.log", data => {
            events.push(data);
        });
        TEST_EVENT_BUS.next({event: "event.log", data: {a: 3}});
        expect(events).to.eql([{a: 3}]);
    });

    it("Событие event.error", async function () {
        restoreTestData();
        let producer = new Producer({config: {}});
        await producer.connect();
        let events = [];
        producer.on("error", error => {
            events.push(error);
        });
        TEST_EVENT_BUS.next({event: "event.error", data: new Error("My Error 7")});
        expect(events.length).to.equal(1);
        expect(events[0].message).to.equal("My Error 7");
    });

    it("Ошибка при отправке сообщения", async function () {
        restoreTestData();
        let producer = new Producer({config: {}});
        await producer.connect();
        try {
            let sent_msg = await producer.produce("error-topic", 3, new Buffer("test"));
        } catch (err) {
            expect(err.message).to.equal("Could not produce");
        }
    });

	it("Дисконнект", async function () {
        restoreTestData();
		let producer = new Producer({config: {}});
        await producer.connect();
        expect(TEST_PRODUCER_DISCONNECTED).to.be.false;
        producer.disconnect();
        expect(TEST_PRODUCER_DISCONNECTED).to.be.true;
	});
});