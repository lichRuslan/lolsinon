const {expect} = require("chai");
const rewire = require("rewire");
const {take, filter, map, scan, tap} = require("rxjs/operators");
const _ = require("lodash");
const node_rdkafka = require("node-rdkafka");
const EventEmitter = require("events");
const rib_kafka = rewire("../index");

let TEST_EVENT_HANDLERS = {};
let TEST_CONSUMER_CONNECTED = false;
let TEST_CONSUMER_DISCONNECTED = false;
let TEST_ASSIGNMENTS = [];
let TEST_POSITIONS = [];
let TEST_SUBSCRIPTION = [];
let MESSAGE_QUEUE = null;
let TEST_COMMITTED_MESSAGES = [];

let TEST_SENT_MESSAGES = [];
let TEST_WRITTEN_OFFSET = null;

function restoreTestData () {
	TEST_EVENT_HANDLERS = {};
	TEST_CONSUMER_CONNECTED = false;
	TEST_CONSUMER_DISCONNECTED = false;
	TEST_ASSIGNMENTS = [];
	TEST_POSITIONS = [];
	TEST_SUBSCRIPTION = [];
	MESSAGE_QUEUE = null;
	TEST_COMMITTED_MESSAGES = [];
	TEST_SENT_MESSAGES = [];
	TEST_WRITTEN_OFFSET = null;
}


class TestKafkaConsumer extends EventEmitter {
	connect (options, cb) {
		TEST_CONSUMER_CONNECTED = true;
		this.mq = MESSAGE_QUEUE(); // инициализируем генраторную функцию
		if (cb) {
			cb(null);
		}
	}

	disconnect () {
		TEST_CONSUMER_CONNECTED = false;
		TEST_CONSUMER_DISCONNECTED = true;
	}

	assign (assignments) {
		TEST_ASSIGNMENTS = assignments;
	}

	seek (postitions) {
		TEST_POSITIONS = postitions;
	}

	subscribe (subscription) {
		TEST_SUBSCRIPTION = subscription;
	}

	consume (num, cb) {
		let {value} = this.mq.next();
		if (_.isUndefined(value)) {
			cb(null, []);
			return;
		}
		let {action, data} = value;
		if (action === "error") {
			cb(data);
		} else if (action === "empty") {
			cb(null, []);
		} else if (action === "event") {
			if (data.name === "rebalance") {
				//TEST_EVENT_HANDLERS["rebalance"](_.pick(data, "code", "message"), data.assignments);
				this.emit("rebalance", _.pick(data, "code", "message"), data.assignments);
			} else {
				//TEST_EVENT_HANDLERS[data.name](data);
				this.emit(data.name, data);
			}
			cb(null, []);
		} else {
			cb(null, [data]);
		}
		/*yield {action: "event", data: {name: "event.error", message: "broker transport failure"}}
		yield {action: "event", data: {name: "rebalance", code: -175, assignments: [{topic: "test_topic", partition: 0}]}}
		yield {action: "event", data: {name: "rebalance", code: -177, message: "assignment error"}},*/
	}

	commitSync (msg) {
		TEST_COMMITTED_MESSAGES.push(msg);
		return true;
	}

	//on (event, handler) {
	//	TEST_EVENT_HANDLERS[event] = handler;
	//}
}

class TestKafkaProducer extends EventEmitter {
	connect (options, cb) {
		cb(null);
	}

	produce (topic, partition, value, key, timestamp, opaque) {
		TEST_SENT_MESSAGES.push({topic, partition, key, value, timestamp});
		this.emit("delivery-report", null, {topic, partition, offset: TEST_WRITTEN_OFFSET++, key, value, timestamp, opaque});
	}
	
	setPollInterval () {}
}

rib_kafka.__set__("Kafka", {
	"KafkaConsumer": TestKafkaConsumer,
	"CODES": {
		"ERRORS": node_rdkafka.CODES.ERRORS
	},
	"Producer": TestKafkaProducer
});

const Consumer = rib_kafka.getConsumerClass();

describe("Тестирование реактивного consumer", function () {
	it("Получение сообщений - через Observable", async function () {
		restoreTestData();

		MESSAGE_QUEUE = function* () {
			yield {action: "message", data: "message1"};
			yield {action: "empty", data: ""};
			yield {action: "empty", data: ""};
			yield {action: "message", data: "message2"};
			yield {action: "empty", data: ""};
			yield {action: "empty", data: ""};
			yield {action: "empty", data: ""};
			yield {action: "message", data: "message3"};
			yield {action: "empty", data: ""};
			yield {action: "message", data: "message4"};
		};
        
		let consumer = new Consumer({topics: ["test_topic_1"]});
		await consumer.connect();
		let consumer_observable = consumer.getObservable();
		
		let messages = await consumer_observable.pipe(
			take(2),
			filter(({action, action_data}) => action === "data"),
			map(({action, action_data}) => action_data),
			scan((acc, msg) => { acc.push(msg); return acc; }, [])
		).toPromise();
		expect(messages).to.eql(["message1", "message2"]);
		expect(TEST_CONSUMER_DISCONNECTED).to.be.false;
		expect(TEST_CONSUMER_CONNECTED).to.be.true;
		messages = await consumer_observable.pipe(take(2), filter(({action, action_data}) => action === "data"), map(({action, action_data}) => action_data), scan((acc, msg) => { acc.push(msg); return acc; }, [])).toPromise();
		expect(messages).to.eql(["message3", "message4"]);
		expect(TEST_CONSUMER_DISCONNECTED).to.be.false;
		expect(TEST_CONSUMER_CONNECTED).to.be.true;
	});

	it("Получение сообщений - consume", async function () {
		restoreTestData();

		MESSAGE_QUEUE = function* () {
			yield {action: "message", data: "message1"};
			yield {action: "empty", data: ""};
			yield {action: "empty", data: ""};
			yield {action: "message", data: "message2"};
			yield {action: "empty", data: ""};
			yield {action: "empty", data: ""};
			yield {action: "empty", data: ""};
			yield {action: "message", data: "message3"};
			yield {action: "empty", data: ""};
			yield {action: "message", data: "message4"};
		};
        
		let consumer = new Consumer({topics: ["test_topic_1"]});
		await consumer.connect();
		let messages = [];
		let count = 0;
		let errors = [];
		consumer.on("error", err => errors.push(err));
		await consumer.consume(async (msg, next) => {
			messages.push(msg);
			count += 1;
			if (count === 3) {
				next({message: 1});
			} else {
				next();
			}
		});

		expect(messages).to.eql(["message1", "message2", "message3"]);
		expect(errors).to.eql([{message: 1}]);
	});

	it("Получение сообщений - consume + finish", async function () {
		restoreTestData();

		MESSAGE_QUEUE = function* () {
			yield {action: "message", data: "message1"};
			yield {action: "empty", data: ""};
			yield {action: "empty", data: ""};
			yield {action: "message", data: "message2"};
			yield {action: "empty", data: ""};
			yield {action: "empty", data: ""};
			yield {action: "empty", data: ""};
			yield {action: "message", data: "message3"};
			yield {action: "empty", data: ""};
			yield {action: "message", data: "message4"};
		};
        
		let consumer = new Consumer({topics: ["test_topic_1"]});
		await consumer.connect();
		let messages = [];
		let count = 0;
		let errors = [];
		consumer.on("error", err => errors.push(err));
		await consumer.consume(async (msg, next) => {
			messages.push(msg);
			count += 1;
			if (count === 3) {
				next.finish();
			} else {
				next();
			}
		});

		expect(messages).to.eql(["message1", "message2", "message3"]);
		expect(errors).to.eql([]);
	});

	it("Получение сообщений - consume - Ошибка при получении сообщения", async function () {
		restoreTestData();

		MESSAGE_QUEUE = function* () {
			yield {action: "message", data: "message1"};
			yield {action: "error", data: new Error ("consume error")};
		};
        
		let consumer = new Consumer({topics: ["test_topic_1"]});
		await consumer.connect();
		let messages = [];
		let errors = [];

		consumer.on("error", err => {
			errors.push(err);
		});

        await consumer.consume(async (msg, next) => {
            messages.push(msg);
    	    next();
    	});

		expect(messages).to.eql(["message1"]);
		expect(errors.length).to.equal(1);
		expect(errors[0].message).to.equal("consume error");
	});

	it("Получение сообщений - consume - Ошибка в функции обработки", async function () {
		restoreTestData();

		MESSAGE_QUEUE = function* () {
			yield {action: "message", data: "message1"};
            yield {action: "message", data: "message2"};
            yield {action: "message", data: "message3"};
            yield {action: "message", data: "message4"};
            yield {action: "message", data: "message5"};
		};
        
		let consumer = new Consumer({topics: ["test_topic_1"]});
		await consumer.connect();
		let messages = [];
		let count = 0;
		let errors = [];
		consumer.on("error", err => errors.push(err));
		
		await consumer.consume(async (msg, next) => {
			throw new Error("my error");
		});
		expect(messages).to.eql([]);
		expect(errors.length).to.equal(1);
		expect(errors[0].message).to.equal("my error");

		await consumer.consume((msg, next) => {
			throw new Error("my error1");
		});
		expect(messages).to.eql([]);
		expect(errors.length).to.equal(2);
		expect(errors[1].message).to.equal("my error1");

		await consumer.consume((msg, next) => {
			next(new Error("my error2"));
		});
		expect(messages).to.eql([]);
		expect(errors.length).to.equal(3);
		expect(errors[2].message).to.equal("my error2");
	});

	it("Ошибка во время получения сообщений", async function () {
		restoreTestData();

		MESSAGE_QUEUE = function* () {
			yield {action: "message", data: "message1"};
			yield {action: "error", data: new Error ("consume error")};
			yield {action: "message", data: "message6"};
		};
        
		let consumer = new Consumer({topics: ["test_topic_1"]});
		await consumer.connect();
		let consumer_observable = consumer.getObservable();

		try {
			await consumer_observable.pipe(take(2), filter(({action, action_data}) => action === "data"), map(({action, action_data}) => action_data), scan((acc, msg) => { acc.push(msg); return acc; }, [])).toPromise();
		} catch (err) {
			expect(err.message).to.equal("consume error");
		}
	});
	it("Ошибка в работе rdkafka", async function () {
		restoreTestData();

		MESSAGE_QUEUE = function* () {
			yield {action: "message", data: "message6"};
			yield {action: "event", data: {name: "event.error", message: "broker transport failure"}};
			yield {action: "message", data: "message7"};
			yield {action: "event", data: {name: "event.error", message: "All brokers down"}};
		};
        
		let consumer = new Consumer({topics: ["test_topic_1"]});
		await consumer.connect();
		let consumer_observable = consumer.getObservable();
		let messages = [];
		consumer_observable.pipe(
			take(3),
			filter(({action, action_data}) => action === "data"),
			map(({action, action_data}) => action_data),
			scan((acc, msg) => { acc.push(msg); return acc; }, [])
		).subscribe(msg => {
			messages = msg;
		});
		try {
			await consumer.getErrorObservable().pipe(take(1)).toPromise();
		} catch (err) {
			expect(err.message).to.equal("All brokers down");
		}
	});
	it("Ошибка во время получения сообщений", async function () {
		restoreTestData();

		MESSAGE_QUEUE = function* () {
			yield {action: "message", data: "message1"};
			yield {action: "error", data: new Error ("consume error")};
			yield {action: "message", data: "message6"};
		};
        
		let consumer = new Consumer({topics: ["test_topic_1"]});
		await consumer.connect();
		let consumer_observable = consumer.getObservable();

		try {
			await consumer_observable.pipe(take(2), filter(({action, action_data}) => action === "data"), map(({action, action_data}) => action_data), scan((acc, msg) => { acc.push(msg); return acc; }, [])).toPromise();
		} catch (err) {
			expect(err.message).to.equal("consume error");
		}
	});
	it("Ошибка во время ребалансировки ", async function () {
		restoreTestData();

		MESSAGE_QUEUE = function* () {
			yield {action: "message", data: "message5"};
			yield {action: "event", data: {name: "rebalance", code: -174, assignments: [{topic: "test_topic", partition: 0}]}};
			yield {action: "event", data: {name: "rebalance", code: -175, assignments: [{topic: "test_topic", partition: 0}]}};
			yield {action: "message", data: "message6"};
			yield {action: "event", data: {name: "rebalance", code: -177, message: "assignment error"}};
		};
        
		let consumer = new Consumer({topics: ["test_topic_1"]});
		await consumer.connect();
		let consumer_observable = consumer.getObservable();

		consumer_observable.pipe(
			take(3),
			filter(({action, action_data}) => action === "data"),
			map(({action, action_data}) => action_data),
			scan((acc, msg) => { acc.push(msg); return acc; }, [])
		).subscribe(msg => {});



		let {action, action_data} = await consumer.getErrorObservable().pipe(take(1)).toPromise();
        expect(action_data.message).to.equal("assignment error");
	});
});

describe("Тестирование реактивного consumer с контролем лимитов", function () {
	it("Получение всех сообщений", async function () {
		restoreTestData();

		MESSAGE_QUEUE = function* () {
			yield {action: "data", data: {topic: "test_topic", partition: 0, offset: 10, key: "message1", value: new Buffer("")}};
			yield {action: "data", data: {topic: "test_topic", partition: 1, offset: 15, key: "message2", value: new Buffer("")}};
			yield {action: "data", data: {topic: "test_topic", partition: 0, offset: 11, key: "message3", value: new Buffer("")}};
			yield {action: "data", data: {topic: "test_topic", partition: 0, offset: 12, key: "message4", value: new Buffer("")}};
			yield {action: "data", data: {topic: "test_topic", partition: 1, offset: 16, key: "message6", value: new Buffer("")}};
			yield {action: "data", data: {topic: "test_topic", partition: 0, offset: 13, key: "message5", value: new Buffer("")}};
			yield {action: "data", data: {topic: "test_topic", partition: 1, offset: 17, key: "message7", value: new Buffer("")}};
			yield {action: "data", data: {topic: "test_topic", partition: 1, offset: 18, key: "message8", value: new Buffer("")}};
			yield {action: "data", data: {topic: "test_topic", partition: 1, offset: 19, key: "message9", value: new Buffer("")}};
		};

		class Consumer1 extends Consumer {
			async queryWatermarkOffsets ({topic, partition}) {
				if (topic === "test_topic" && partition === 0) {
					return {highOffset: 12, lowOffset: 8};
				}
				throw new Error("Error3");
			}
		}
        
		let consumer = new Consumer1 ({
			assignments: [{topic: "test_topic", partition: 0, offset: 10}, {topic: "test_topic", partition: 1, offset: 15}],
			limits: [{topic: "test_topic", partition: 0, offset: "end"}, {topic: "test_topic", partition: 1, offset: 18}]
		});
		await consumer.connect();
		let consumer_observable = consumer.getObservable();
		
		let messages = await consumer_observable.pipe(filter(({action}) => action === "data"), map(({action_data}) => action_data), scan((acc, msg) => {acc.push(msg.key);return acc;}, [])).toPromise();
		expect(messages).to.eql(["message1", "message2", "message3", "message4", "message6", "message7", "message8"]);
		expect(TEST_CONSUMER_DISCONNECTED).to.be.true;
		expect(TEST_CONSUMER_CONNECTED).to.be.false;
	});
	it("Ошибка при запросе оффсета партиции", async function () {
		restoreTestData();

		MESSAGE_QUEUE = function* () {
			yield {action: "error", data: new Error("My Error 1")};
		};

		class Consumer1 extends Consumer {
			async queryWatermarkOffsets () {
				throw new Error("Error3");
			}
		}
        
		let consumer = new Consumer1 ({
			assignments: [{topic: "test_topic", partition: 0, offset: 10}, {topic: "test_topic", partition: 1, offset: 10}, {topic: "test_topic_1", partition: 3, offset: 0}],
			limits: [{topic: "test_topic", partition: 0, offset: "latest"}]
		});
		
		//let consumer_observable = consumer.getObservable();
		
		try {
			await consumer.connect();
			//await consumer_observable.pipe(filter(({action, action_data}) => action === "data"), map(({action, action_data}) => action_data), scan((acc, msg) => { acc.push(msg); return acc; }, [])).toPromise();
		} catch (err) {
			expect(err.message).to.equal("Error3");
		}
	});
});